// Description: dignore - dockerignore generate by dockerfile configuration
// Developer: Nissim Bitan
// Email: nissim.bitan@aquasec.com

package main

import (
	"bufio"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"strings"

	"github.com/pkg/errors"
	"github.com/spf13/cobra"
)

var Context string
var Dockerfile string
var Overide bool
var Result string

var rootCmd = &cobra.Command{
	Use:   "dignore [flags]",
	Short: "",
	Long:  ``,
	RunE:  Run,
}

func init() {
	rootCmd.PersistentFlags().StringVarP(&Context, "context", "c", ".", "Set docker context directory path")
	rootCmd.PersistentFlags().StringVarP(&Dockerfile, "dockerfile", "d", "Dockerfile", "Set dockerfile path or folder of dockerfiles")
	rootCmd.PersistentFlags().BoolVarP(&Overide, "overide", "o", false, "Overide if existing .dockerignore file")
	rootCmd.PersistentFlags().StringVarP(&Result, "result", "r", ".dockerignore", "Set result file")

}

func Run(cmd *cobra.Command, args []string) error {
	var err error
	files := []string{}

	if Context != "." {
		if _, err = os.Stat(Context); err != nil {
			return errors.New("given context file don't exists")
		}
	}

	if _, err = os.Stat(Dockerfile); err != nil {
		return errors.New("given Dockerfile path don't exists")
	}

	dir, err := isDirectory(Dockerfile)
	if err != nil {
		return err
	}

	if dir {
		dirname := Dockerfile
		dockerfiles, err := ioutil.ReadDir(dirname)
		if err != nil {
			log.Fatal(err)
		}

		if dirname[len(dirname)-1:] != "/" {
			dirname = fmt.Sprintf("%s/", dirname)
		}

		for _, file := range dockerfiles {
			if strings.HasPrefix(file.Name(), "Dockerfile") {
				Dockerfile = fmt.Sprintf("%s%s", dirname, file.Name())
				currentfiles, err := getFiles()
				if err != nil {
					return err
				}
				files = append(files, currentfiles...)
			}
		}
	} else {
		files, err = getFiles()
		if err != nil {
			return err
		}
	}

	err = createDockerignore(files)
	if err != nil {
		return err
	}

	return nil
}

func getFiles() ([]string, error) {
	files := []string{}

	f, err := os.Open(Dockerfile)
	if err != nil {
		return nil, err
	}

	defer f.Close() // nolint: errcheck

	scanner := bufio.NewScanner(f)
	for scanner.Scan() {
		line := scanner.Text()
		if (strings.HasPrefix(line, "ADD") || strings.HasPrefix(line, "COPY")) &&
			(!strings.HasPrefix(line, "COPY --from=")) {
			currentFiles := strings.Split(line, " ")
			if len(currentFiles) <= 2 {
				return nil, errors.New("Wrong ADD or COPY file in Dockerfile")
			}

			currentFiles = currentFiles[1 : len(currentFiles)-1]
			files = append(files, currentFiles...)
		}
	}

	if err := scanner.Err(); err != nil {
		return nil, err
	}

	return files, nil
}

func isDirectory(path string) (bool, error) {
	var err error

	if Context != "." {
		path = fmt.Sprintf("%s/%s", Context, path)
	}

	if strings.Contains(path, "*") {
		return false, nil
	}

	file, err := os.Stat(path)
	if err != nil {
		return false, errors.Wrap(err, "File or directory don't exists")
	}

	mode := file.Mode()
	if mode.IsDir() {
		return true, nil
	}

	return false, nil
}

func createDockerignore(files []string) error {
	var err error
	exists := false
	var file *os.File
	_, err = os.Stat(Result)
	if err == nil {
		if Overide {
			err = os.Remove(Result)
			if err != nil {
				return err
			}
		} else {
			exists = true
		}
	}

	if !exists {
		file, err = os.Create(Result)
		if err != nil {
			return err
		}

		fmt.Fprintln(file, "# Generated by dignore")
		fmt.Fprintln(file, "*")
		fmt.Fprintln(file, ".git")
	} else {
		file, err = os.OpenFile(Result, os.O_APPEND|os.O_WRONLY, 0600)
		if err != nil {
			return err
		}
	}

	for _, item := range files {
		dir, err := isDirectory(item)
		if err != nil {
			return err
		}

		if dir {
			if item[len(item)-1:] == "/" {
				fmt.Fprintln(file, fmt.Sprintf("!%s*", item))
			} else {
				fmt.Fprintln(file, fmt.Sprintf("!%s/*", item))
			}
		} else {
			fmt.Fprintln(file, fmt.Sprintf("!%s", item))
		}
		if err != nil {
			return err
		}
	}

	defer file.Close() // nolint: errcheck

	return nil
}

func main() {
	if err := rootCmd.Execute(); err != nil {
		fmt.Fprintln(os.Stderr, err) // nolint: errcheck
		os.Exit(1)
	}
}
